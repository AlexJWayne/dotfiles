{"id":"831a276b-d954-4fe6-b87b-761300f5531a","zed":"context","version":"0.4.0","text":"\n\n\n```odin PlasmaPlanetV5/source/spark.odin\npackage game\n\nimport \"core:c\"\nimport \"core:fmt\"\nimport \"grid\"\nimport rl \"vendor:raylib\"\nimport rlgl \"vendor:raylib/rlgl\"\n\n_ :: fmt\n\nSpark :: struct {\n\tusing grid_cell: grid.GridCell,\n\tprev_cell:       [2]i32,\n\tvalue:           i32,\n\tstate:           SparkState,\n\talive:           bool,\n}\n\nSparkState :: enum {\n\tBirthing   = 0,\n\tMoving     = 1,\n\tHarvesting = 2,\n\tDying      = 3,\n}\n\nfrag_shader: rl.Shader\n\nSparkFragShader :: struct {\n\tshader: rl.Shader,\n\tstate:  c.int,\n}\nspark_frag_shader: SparkFragShader\n\nspark_load :: proc() {\n\tdata := #load(\"spark.frag.glsl\", cstring)\n\tspark_frag_shader = {\n\t\tshader = rl.LoadShaderFromMemory(nil, data),\n\t}\n\n\tspark_frag_shader.state = rl.GetShaderLocation(\n\t\tspark_frag_shader.shader,\n\t\t\"state\",\n\t)\n}\n\nspark_create :: proc(cell: [2]i32, value: i32) {\n\tspark_get_free_index := proc() -> (index: int, ok: bool) {\n\t\tfor spark, i in game.world.sparks {\n\t\t\tif !spark.alive do return i, true\n\t\t}\n\t\treturn 0, false\n\t}\n\n\tspark := Spark {\n\t\tcell      = cell,\n\t\tprev_cell = cell,\n\t\tvalue     = value,\n\t\tstate     = .Birthing,\n\t\talive     = true,\n\t}\n\n\tif i, ok := spark_get_free_index(); ok {\n\t\tgame.world.sparks[i] = spark\n\t} else {\n\t\tappend(&game.world.sparks, spark)\n\t}\n}\n\nspark_tick :: proc(spark: ^Spark) {\n\tif !spark.alive do return\n\n\tspark.prev_cell = spark.cell\n\n\tif spark.state == .Dying {\n\t\tspark.alive = false\n\t\treturn\n\t}\n\n\tif spark.state == .Harvesting {\n\t\tspark.alive = false\n\t\treturn\n\t}\n\n\tif harvester, h_ok := game.world.harvesters[spark.cell]; h_ok {\n\t\tharvester_handle_spark(harvester, spark)\n\t} else if pipe, p_ok := game.world.pipes[spark.cell]; p_ok {\n\t\tpipe_handle_spark(pipe, spark)\n\t} else if collector, c_ok := game.world.collectors[spark.cell]; c_ok {\n\t\tcollector_handle_spark(collector, spark)\n\t} else {\n\t\tspark.state = .Dying\n\t}\n}\n\nspark_render :: proc(spark: Spark) {\n\tget_offset := proc(spark: Spark) -> rl.Vector2 {\n\t\treturn(\n\t\t\t(grid.to_vec(spark.prev_cell) - grid.to_vec(spark.cell)) *\n\t\t\t(1 - game.beat_timer.beat_completion) \\\n\t\t)\n\t}\n\n\tif !spark.alive do return\n\n\trlgl.PushMatrix()\n\tdefer rlgl.PopMatrix()\n\tgrid.translate_to_cell(spark)\n\n\toffset := get_offset(spark)\n\trlgl.Translatef(offset.x, offset.y, 0)\n\n\t// beat_completion := game.beat_timer.beat_completion\n\n\t{\n\t\trl.BeginShaderMode(spark_frag_shader.shader)\n\t\tdefer rl.EndShaderMode()\n\t\trl.SetShaderValue(\n\t\t\tspark_frag_shader.shader,\n\t\t\tspark_frag_shader.state,\n\t\t\trawptr(spark.state),\n\t\t\t.INT,\n\t\t)\n\n\t\trl.DrawRectangleV(-0.5, 1, rl.WHITE)\n\t}\n\n\t// switch spark.state {\n\t// case .Birthing:\n\t// \trl.DrawRectangleV(-0.5, 1, rl.WHITE)\n\t// case .Moving:\n\t// \trl.DrawRectangleV(0, 0.3, rl.WHITE)\n\t// case .Harvesting:\n\t// \trl.DrawRectangleV(\n\t// \t\t0,\n\t// \t\t0.3 + 0.3 * beat_completion,\n\t// \t\t{0xff, 0, 0, u8(f32(0xff) * beat_until)},\n\t// \t)\n\t// case .Dying:\n\t// \trl.DrawCircleV(0, 0.3 * beat_until, rl.WHITE)\n\t// }\n}\n```\n\nHow do I get a rawptr from `spark.state` to pass to `rl.SetShaderValue`?\n\nTo get a raw pointer from `spark.state` to pass to `rl.SetShaderValue`, you need to ensure that the value is properly cast to the expected type. In this case, `spark.state` is an enum, and you need to pass a pointer to its integer representation.\n\nHere's how you can do it:\n\n1. Cast the enum value to an integer.\n2. Get a pointer to the integer value.\n\nHere's the updated `spark_render` function with the necessary changes:\n\n```odin\nspark_render :: proc(spark: Spark) {\n\tget_offset := proc(spark: Spark) -> rl.Vector2 {\n\t\treturn(\n\t\t\t(grid.to_vec(spark.prev_cell) - grid.to_vec(spark.cell)) *\n\t\t\t(1 - game.beat_timer.beat_completion) \\\n\t\t)\n\t}\n\n\tif !spark.alive do return\n\n\trlgl.PushMatrix()\n\tdefer rlgl.PopMatrix()\n\tgrid.translate_to_cell(spark)\n\n\toffset := get_offset(spark)\n\trlgl.Translatef(offset.x, offset.y, 0)\n\n\t// beat_completion := game.beat_timer.beat_completion\n\n\t{\n\t\trl.BeginShaderMode(spark_frag_shader.shader)\n\t\tdefer rl.EndShaderMode()\n\n\t\t// Cast the enum value to an integer\n\t\tstate_value := c.int(spark.state)\n\n\t\t// Get a pointer to the integer value\n\t\tstate_ptr := rawptr(&state_value)\n\n\t\trl.SetShaderValue(\n\t\t\tspark_frag_shader.shader,\n\t\t\tspark_frag_shader.state,\n\t\t\tstate_ptr,\n\t\t\t.INT,\n\t\t)\n\n\t\trl.DrawRectangleV(-0.5, 1, rl.WHITE)\n\t}\n\n\t// switch spark.state {\n\t// case .Birthing:\n\t// \trl.DrawRectangleV(-0.5, 1, rl.WHITE)\n\t// case .Moving:\n\t// \trl.DrawRectangleV(0, 0.3, rl.WHITE)\n\t// case .Harvesting:\n\t// \trl.DrawRectangleV(\n\t// \t\t0,\n\t// \t\t0.3 + 0.3 * beat_completion,\n\t// \t\t{0xff, 0, 0, u8(f32(0xff) * beat_until)},\n\t// \t)\n\t// case .Dying:\n\t// \trl.DrawCircleV(0, 0.3 * beat_until, rl.WHITE)\n\t// }\n}\n```\n\nIn this code, `state_value` is an integer representation of `spark.state`, and `state_ptr` is a pointer to `state_value`. This pointer is then passed to `rl.SetShaderValue`. This ensures that the shader receives the correct value for the `state` uniform.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":76}}},{"id":{"replica_id":0,"value":55},"start":2952,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":77}}},{"id":{"replica_id":0,"value":56},"start":4831,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":78}}}],"summary":"Passing Enum to Shader","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default","metadata":null},{"range":{"start":3,"end":2877},"icon":"File","label":"PlasmaPlanetV5/source/spark.odin","metadata":{"path":"PlasmaPlanetV5/source/spark.odin"}}]}