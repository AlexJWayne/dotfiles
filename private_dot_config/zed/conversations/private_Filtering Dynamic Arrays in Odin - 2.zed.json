{"id":"2dfbe542-f4ef-41d9-a77e-669144970ec8","zed":"context","version":"0.4.0","text":"\n\nHow do I filter a dynamic array in Odin lang?\n\nIn Odin, you can filter a dynamic array by iterating over the elements and conditionally adding them to a new dynamic array based on a specified condition. Here's an example to illustrate how you can achieve this:\n\n```odin\npackage main\n\nimport \"core:fmt\"\n\nmain :: proc() {\n    // Define a dynamic array of integers\n    numbers: []int = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n\n    // Define a new dynamic array to hold the filtered results\n    filtered_numbers: []int\n\n    // Define the condition for filtering (e.g., keep only even numbers)\n    condition := proc(n: int) -> bool {\n        return n % 2 == 0\n    }\n\n    // Iterate over the original array and apply the condition\n    for n in numbers {\n        if condition(n) {\n            filtered_numbers = append(filtered_numbers, n)\n        }\n    }\n\n    // Print the filtered array\n    fmt.println(\"Filtered numbers:\", filtered_numbers)\n}\n```\n\nIn this example:\n1. We define a dynamic array `numbers` containing integers from 1 to 10.\n2. We create an empty dynamic array `filtered_numbers` to store the filtered results.\n3. We define a condition function that returns `true` for even numbers.\n4. We iterate over the `numbers` array, and for each element, we check if it satisfies the condition.\n5. If the condition is met, we append the element to the `filtered_numbers` array.\n6. Finally, we print the filtered array.\n\nYou can modify the `condition` function to filter based on different criteria as needed.\nMake a filter procedure\nCertainly! You can create a reusable filter procedure in Odin that takes a dynamic array and a condition function as arguments, and returns a new dynamic array containing only the elements that satisfy the condition. Here's how you can do it:\n\n```odin\npackage main\n\nimport \"core:fmt\"\n\n// Define the filter procedure\nfilter :: proc(arr: []int, condition: proc(n: int) -> bool) -> []int {\n    filtered: []int\n    for n in arr {\n        if condition(n) {\n            filtered = append(filtered, n)\n        }\n    }\n        \n```odin PlasmaPlanetV5/source/world.odin\npackage game\n\n// import \"core:fmt\"\nimport \"grid\"\nimport rl \"vendor:raylib\"\nimport rlgl \"vendor:raylib/rlgl\"\n\n\nWorld :: struct {\n\tsparks:     [dynamic]Spark,\n\tsources:    map[[2]i32]Source,\n\tharvesters: map[[2]i32]Harvester,\n}\n\nRENDER_RADIUS: i32 = 10\n\nworld_init :: proc() -> World {\n\tworld := World{}\n\n\tworld.sources[{-1, -1}] = Source {\n\t\tcell            = {-1, -1},\n\t\tproduce_on_beat = 0,\n\t}\n\tworld.sources[{0, 0}] = Source {\n\t\tcell            = {0, 0},\n\t\tproduce_on_beat = 1,\n\t}\n\tworld.sources[{1, 1}] = Source {\n\t\tcell            = {1, 1},\n\t\tproduce_on_beat = 2,\n\t}\n\n\tworld.harvesters[{1, 1}] = Harvester {\n\t\tcell = {1, 1},\n\t\tdir  = .Right,\n\t}\n\n\treturn world\n}\n\nworld_update :: proc() {\n\tfor &spark in game.world.sparks do spark_pre_update(&spark)\n\tfor _, harvester in game.world.harvesters do harvester_update(harvester)\n\tfor _, source in game.world.sources do source_update(source)\n\n\t\n\tfor spark in game.world.sparks {\n\t    spark_post_update(spark, i)\n\t}\n}\n\n\nworld_render :: proc() {\n\trl.BeginMode2D(make_rl_camera())\n\tdefer rl.EndMode2D()\n\n\tworld_render_cells()\n\tworld_render_hovered_cell()\n}\n\nworld_render_cells :: proc() {\n\tgrid.for_each_cell(\n\t\t{i32(game.camera.pos.x), i32(game.camera.pos.y)},\n\t\tRENDER_RADIUS,\n\t\tproc(pos: [2]i32) {\n\t\t\trlgl.PushMatrix()\n\t\t\tdefer rlgl.PopMatrix()\n\t\t\trlgl.Translatef(f32(pos.x), f32(pos.y), 0)\n\n\t\t\trl.DrawRectangleLines(0, 0, 1, 1, rl.DARKGRAY)\n\t\t},\n\t)\n\n\n\tfor _, source in game.world.sources do source_render(source)\n\tfor spark in game.world.sparks do spark_render(spark)\n\tfor _, harvester in game.world.harvesters do harvester_render(harvester)\n}\n\nworld_render_hovered_cell :: proc() {\n\thovered_cell, has_hovered_cell := game.ui.hovered_cell.?\n\tif has_hovered_cell do rl.DrawRectangleLines(hovered_cell.x, hovered_cell.y, 1, 1, rl.YELLOW)\n}\n\nworld_create_entity :: proc(\n\ttype: Maybe(Entity),\n\tcell: [2]i32,\n) -> Maybe(Entity) {\n\ttype, ok := type.?\n\tif !ok do return nil\n\n\tswitch _ in type {\n\tcase Source:\n\t\treturn Source{cell = cell, produce_on_beat = game.beat_timer.beat}\n\tcase Pipe:\n\t\treturn Pipe{pos = cell}\n\tcase Collector:\n\t\treturn Collector{pos = cell}\n\t}\n\treturn nil\n}\n\nworld_pos_from_screen :: proc() -> rl.Vector2 {\n\treturn rl.GetScreenToWorld2D(rl.GetMousePosition(), make_rl_camera())\n}\n\nworld_pos_to_cell_pos :: proc(pos: rl.Vector2) -> [2]i32 {\n\tpos := pos\n\tif pos.x < 0 {pos.x -= 1}\n\tif pos.y < 0 {pos.y -= 1}\n\treturn [2]i32{i32(pos.x), i32(pos.y)}\n}\n\nworld_shutdown :: proc() {\n\t// TODO: free memory?\n}\n```\n\n    \n    return filtered\n}\n\nmain :: proc() {\n    // Define a dynamic array of integers\n    numbers: []int = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n\n    // Define the condition for filtering (e.g., keep only even numbers)\n    is_even := proc(n: int) -> bool {\n        return n % 2 == 0\n    }\n\n    // Use the filter procedure to get the filtered array\n    filtered_numbers := filter(numbers, is_even)\n\n    // Print the filtered array\n    fmt.println(\"Filtered numbers:\", filtered_numbers)\n}\n```\n\nIn this example:\n1. We define a `filter` procedure that takes a dynamic array `arr` and a condition function `condition` as arguments. The condition function takes an integer and returns a boolean.\n2. Inside the `filter` procedure, we create an empty dynamic array `filtered` to store the filtered results.\n3. We iterate over the input array `arr`, and for each element, we check if it satisfies the condition.\n4. If the condition is met, we append the element to the `filtered` array.\n5. We return the `filtered` array.\n6. In the `main` procedure, we define a dynamic array `numbers` and a condition function `is_even` that returns `true` for even numbers.\n7. We call the `filter` procedure with `numbers` and `is_even` to get the filtered array.\n8. Finally, we print the filtered array.\n\nThis approach allows you to reuse the `filter` procedure with different arrays and condition functions as needed.\nHow can I filter `game.world.sparks` to only include sparks that are alive?\nTo filter `game.world.sparks` to only include sparks that are alive, you can create a filter procedure similar to the one we discussed earlier. Assuming that each `Spark` struct has a boolean field `alive` that indicates whether the spark is alive, you can filter the array based on this field.\n\nHere's how you can do it:\n\n1. Define a `filter` procedure that works with an array of `Spark` structs.\n2. Define a condition function that checks if a spark is alive.\n3. Use the `filter` procedure to get the filtered array of alive sparks.\n\nHere's an example implementation:\n\n```odin\npackage main\n\nimport \"core:fmt\"\n\n// Define the Spark struct\nSpark :: struct {\n    alive: bool\n    // Other fields...\n}\n\n// Define the World struct\nWorld :: struct {\n    sparks: [dynamic]Spark\n    // Other fields...\n}\n\n// Define the filter procedure for an array of Spark structs\nfilter_sparks :: proc(arr: []Spark, condition: proc(s: Spark) -> bool) -> []Spark {\n    filtered: []Spark\n    for s in arr {\n        if condition(s) {\n            filtered = append(filtered, s)\n        }\n    }\n    return filtered\n}\n\n// Define the condition function to check if a spark is alive\nis_alive :: proc(s: Spark) -> bool {\n    return s.alive\n}\n\nmain :: proc() {\n    // Initialize the world with some sparks\n    game.world = World{\n        sparks = []Spark{\n            {alive = true},\n            {alive = false},\n            {alive = true},\n            {alive = false},\n            {alive = true},\n        }\n    }\n\n    // Use the filter procedure to get only the alive sparks\n    alive_sparks := filter_sparks(game.world.sparks, is_alive)\n\n    // Print the filtered array of alive sparks\n    fmt.println(\"Alive sparks:\", alive_sparks)\n}\n```\n\nIn this example:\n1. We define a `Spark` struct with a boolean field `alive`.\n2. We define a `World` struct that contains a dynamic array of `Spark` structs.\n3. We define a `filter_sparks` procedure that takes an array of `Spark` structs and a condition function as arguments, and returns a new array containing only the sparks that satisfy the condition.\n4. We define the `is_alive` condition function that checks if a spark is alive.\n5. In the `main` procedure, we initialize the `game.world` with some sparks, some of which are alive and some are not.\n6. We use the `filter_sparks` procedure with the `is_alive` condition function to get the filtered array of alive sparks.\n7. Finally, we print the filtered array of alive sparks.\n\nThis approach allows you to filter the `game.world.sparks` array to include only the sparks that are alive.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":224}}},{"id":{"replica_id":0,"value":28},"start":49,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":225}}},{"id":{"replica_id":0,"value":29},"start":1502,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":226}}},{"id":{"replica_id":0,"value":107},"start":1526,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":227}}},{"id":{"replica_id":0,"value":108},"start":5948,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":228}}},{"id":{"replica_id":0,"value":214},"start":6024,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":229}}},{"id":{"replica_id":0,"value":215},"start":8577,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":230}}}],"summary":"Filtering Dynamic Arrays in Odin","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default","metadata":null},{"range":{"start":2046,"end":4556},"icon":"File","label":"PlasmaPlanetV5/source/world.odin","metadata":{"path":"PlasmaPlanetV5/source/world.odin"}}]}