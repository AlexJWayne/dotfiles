{"id":"8f9d8f27-674c-4bd3-aa07-7188605ed97c","zed":"context","version":"0.4.0","text":"\n\n\n```zig PlasmaPlanetV6/src/entities/rock.zig\nconst rl = @import(\"raylib\");\n\nconst Cell = @import(\"../grid/cell.zig\").Cell;\nconst Direction = @import(\"../grid/direction.zig\").Direction;\n\npub const Rock = struct {\n    cell: Cell,\n    dir: Direction,\n\n    pub fn init() Rock {\n        return Rock.initAt(Cell.origin());\n    }\n\n    pub fn initAt(cell: Cell) Rock {\n        return Rock{\n            .cell = cell,\n            .dir = .Right, // random direction\n        };\n    }\n\n    pub fn render(rock: Rock) void {\n        rl.gl.rlPushMatrix();\n        defer rl.gl.rlPopMatrix();\n        rock.cell.renderAtFacing(rock.dir);\n\n        rl.drawPoly(rl.Vector2.zero(), 7, 0.45, 0, rl.Color.dark_brown);\n    }\n};\n```\n\n```zig PlasmaPlanetV6/src/grid/direction.zig\nconst std = @import(\"std\");\nconst pi = std.math.pi;\n\nconst None: [2]i32 = .{ 0, 0 };\nconst Right: [2]i32 = .{ 1, 0 };\nconst Down: [2]i32 = .{ 0, 1 };\nconst Left: [2]i32 = .{ -1, 0 };\nconst Up: [2]i32 = .{ 0, -1 };\n\npub const Direction = enum {\n    None,\n    Right,\n    Down,\n    Left,\n    Up,\n\n    pub fn vector2i(self: Direction) [2]i32 {\n        return switch (self) {\n            .None => None,\n            .Right => Right,\n            .Down => Down,\n            .Left => Left,\n            .Up => Up,\n        };\n    }\n\n    pub fn radians(self: Direction) f32 {\n        return switch (self) {\n            .None => 0,\n            .Right => pi * 0 / 2,\n            .Down => pi * 1 / 2,\n            .Left => pi * 2 / 2,\n            .Up => pi * 3 / 2,\n        };\n    }\n\n    pub fn degrees(self: Direction) f32 {\n        return switch (self) {\n            .None => 0,\n            .Right => 0,\n            .Down => 90,\n            .Left => 180,\n            .Up => 270,\n        };\n    }\n\n    pub fn right(self: Direction) Direction {\n        return switch (self) {\n            .None => .None,\n            .Right => .Down,\n            .Down => .Left,\n            .Left => .Up,\n            .Up => .Right,\n        };\n    }\n\n    pub fn left(self: Direction) Direction {\n        return switch (self) {\n            .None => .None,\n            .Right => .Up,\n            .Down => .Right,\n            .Left => .Down,\n            .Up => .Left,\n        };\n    }\n\n    pub fn opposite(self: Direction) Direction {\n        return switch (self) {\n            .None => .None,\n            .Right => .Left,\n            .Down => .Up,\n            .Left => .Right,\n            .Up => .Down,\n        };\n    }\n\n    pub fn turnLeft(self: *Direction) void {\n        self.* = self.left();\n    }\n    pub fn turnRight(self: *Direction) void {\n        self.* = self.right();\n    }\n    pub fn flip(self: *Direction) void {\n        self.* = self.opposite();\n    }\n};\n```\n\nHow do I init Rock with a random direction?\n\nTo initialize a `Rock` with a random direction, you can use the `std.rand` module to generate a random number and map that number to one of the directions in the `Direction` enum. Here's how you can modify the `Rock` struct to include this functionality:\n\n1. Import the `std.rand` module.\n2. Add a function to generate a random direction.\n3. Use this function in the `initAt` method.\n\nHere's the updated code:\n\n```zig\nconst rl = @import(\"raylib\");\nconst std = @import(\"std\");\n\nconst Cell = @import(\"../grid/cell.zig\").Cell;\nconst Direction = @import(\"../grid/direction.zig\").Direction;\n\npub const Rock = struct {\n    cell: Cell,\n    dir: Direction,\n\n    pub fn init() Rock {\n        return Rock.initAt(Cell.origin());\n    }\n\n    pub fn initAt(cell: Cell) Rock {\n        return Rock{\n            .cell = cell,\n            .dir = Rock.randomDirection(), // random direction\n        };\n    }\n\n    pub fn render(rock: Rock) void {\n        rl.gl.rlPushMatrix();\n        defer rl.gl.rlPopMatrix();\n        rock.cell.renderAtFacing(rock.dir);\n\n        rl.drawPoly(rl.Vector2.zero(), 7, 0.45, 0, rl.Color.dark_brown);\n    }\n\n    fn randomDirection() Direction {\n        const rng = std.rand.DefaultPrng.init(std.time.nanoTimestamp());\n        const randomIndex = rng.random.int(u32) % 4; // 4 possible directions (Right, Down, Left, Up)\n        return switch (randomIndex) {\n            0 => Direction.Right,\n            1 => Direction.Down,\n            2 => Direction.Left,\n            3 => Direction.Up,\n            else => Direction.None, // This should never happen\n        };\n    }\n};\n```\n\nIn this code:\n- We import the `std` module to access the random number generator.\n- We define a `randomDirection` function that initializes a random number generator and generates a random index between 0 and 3.\n- We map the random index to one of the four possible directions (`Right`, `Down`, `Left`, `Up`).\n- We use the `randomDirection` function in the `initAt` method to initialize the `Rock` with a random direction.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":56}}},{"id":{"replica_id":0,"value":50},"start":2736,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":57}}},{"id":{"replica_id":0,"value":51},"start":4746,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":58}}}],"summary":"Initialize Rock with Random Direction","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default","metadata":null},{"range":{"start":3,"end":708},"icon":"File","label":"PlasmaPlanetV6/src/entities/rock.zig","metadata":{"path":"PlasmaPlanetV6/src/entities/rock.zig"}},{"range":{"start":709,"end":2690},"icon":"File","label":"PlasmaPlanetV6/src/grid/direction.zig","metadata":{"path":"PlasmaPlanetV6/src/grid/direction.zig"}}]}